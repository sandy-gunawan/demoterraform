# CD Pipeline - Terraform Apply
# Applies infrastructure changes to Azure
# Requires manual approval before execution
# Only runs after PR is merged to main

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'infra/**'

pr: none  # Don't run on PRs

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - staging
      - prod
  - name: deploymentTarget
    displayName: 'Terraform Root Module Path'
    type: string
    default: 'infra/envs'
    values:
      - infra/envs
      - infra/platform
      - infra/envs-multiapp
  - name: varFiles
    displayName: 'Var files (comma-separated, optional)'
    type: string
    default: ''
  - name: autoApprove
    displayName: 'Auto Approve (Skip Approval Gate)'
    type: boolean
    default: false

variables:
  - name: terraformVersion
    value: '1.5.7'
  - name: serviceConnection
    value: 'sc-azure-oidc-or-mi'
  - name: azureSubscription
    value: ''  # Set in pipeline variables
  - name: workingDirectory
    value: '$(System.DefaultWorkingDirectory)/${{ parameters.deploymentTarget }}/${{ parameters.environment }}'

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: PrepareApply
    displayName: 'Prepare for Apply'
    jobs:
      - job: ValidateEnvironment
        displayName: 'Validate Environment Configuration'
        steps:
          - checkout: self
          
          - task: PowerShell@2
            displayName: 'Validate Environment Selection'
            inputs:
              targetType: 'inline'
              script: |
                $env = "${{ parameters.environment }}"
                $workDir = "$(workingDirectory)"
                $varFilesParam = "${{ parameters.varFiles }}"
                
                Write-Host "Target Environment: $env"
                Write-Host "Deployment Target: ${{ parameters.deploymentTarget }}"
                Write-Host "Working Directory: $workDir"
                
                if (!(Test-Path $workDir)) {
                  Write-Host "##vso[task.logissue type=error]Environment directory not found: $workDir"
                  exit 1
                }
                
                # Check for required files
                $requiredFiles = @("main.tf", "variables.tf")
                if ([string]::IsNullOrWhiteSpace($varFilesParam)) {
                  $requiredFiles += "$env.tfvars"
                } else {
                  $customVarFiles = $varFilesParam.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
                  $requiredFiles += $customVarFiles
                }
                foreach ($file in $requiredFiles) {
                  $filePath = Join-Path $workDir $file
                  if (!(Test-Path $filePath)) {
                    Write-Host "##vso[task.logissue type=error]Required file missing: $file"
                    exit 1
                  }
                }
                
                Write-Host "âœ“ Environment configuration validated"

  - stage: DeployInfrastructure
    displayName: 'Deploy to ${{ parameters.environment }}'
    dependsOn: PrepareApply
    # Use environment for approval gates
    jobs:
      - deployment: TerraformApply
        displayName: 'Apply Terraform Changes'
        environment: ${{ parameters.environment }}  # This triggers approval gates
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                - task: TerraformInstaller@0
                  displayName: 'Install Terraform'
                  inputs:
                    terraformVersion: $(terraformVersion)
                
                - task: AzureCLI@2
                  displayName: 'Terraform Init'
                  inputs:
                    azureSubscription: $(serviceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    addSpnToEnvironment: true
                    workingDirectory: '$(workingDirectory)'
                    inlineScript: |
                      # Set OIDC environment variables
                      export ARM_CLIENT_ID=$servicePrincipalId
                      export ARM_TENANT_ID=$tenantId
                      export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                      export ARM_USE_OIDC=true
                      
                      # Initialize Terraform
                      terraform init \
                        -input=false \
                        -upgrade=false
                      
                      echo "âœ“ Terraform initialized with remote backend"
                
                - task: AzureCLI@2
                  displayName: 'Terraform Plan (Pre-Apply Check)'
                  inputs:
                    azureSubscription: $(serviceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    addSpnToEnvironment: true
                    workingDirectory: '$(workingDirectory)'
                    inlineScript: |
                      export ARM_CLIENT_ID=$servicePrincipalId
                      export ARM_TENANT_ID=$tenantId
                      export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                      export ARM_USE_OIDC=true

                      # Build var-file arguments
                      if [ -z "${{ parameters.varFiles }}" ]; then
                        TF_VAR_ARGS="-var-file=${{ parameters.environment }}.tfvars"
                      else
                        TF_VAR_ARGS=""
                        IFS=',' read -ra FILES <<< "${{ parameters.varFiles }}"
                        for f in "${FILES[@]}"; do
                          file_trimmed=$(echo "$f" | xargs)
                          TF_VAR_ARGS="$TF_VAR_ARGS -var-file=$file_trimmed"
                        done
                      fi
                      
                      # Generate fresh plan
                      echo "Using var args: $TF_VAR_ARGS"
                      terraform plan $TF_VAR_ARGS -out=tfplan-apply -input=false
                      
                      echo ""
                      echo "==================================="
                      echo "âš ï¸  FINAL PLAN BEFORE APPLY"
                      echo "==================================="
                      terraform show tfplan-apply
                
                - task: AzureCLI@2
                  displayName: 'Terraform Apply'
                  inputs:
                    azureSubscription: $(serviceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    addSpnToEnvironment: true
                    workingDirectory: '$(workingDirectory)'
                    inlineScript: |
                      export ARM_CLIENT_ID=$servicePrincipalId
                      export ARM_TENANT_ID=$tenantId
                      export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                      export ARM_USE_OIDC=true
                      
                      echo "==================================="
                      echo "ðŸš€ APPLYING INFRASTRUCTURE CHANGES"
                      echo "==================================="
                      echo "Environment: ${{ parameters.environment }}"
                      echo "Subscription: $(az account show --query name -o tsv)"
                      echo "Applied By: $(Build.RequestedFor)"
                      echo "Build: $(Build.BuildNumber)"
                      echo ""
                      
                      # Apply with auto-approve
                      terraform apply \
                        -input=false \
                        -auto-approve \
                        tfplan-apply
                      
                      if [ $? -eq 0 ]; then
                        echo ""
                        echo "âœ“ Infrastructure deployed successfully!"
                        echo ""
                        echo "==================================="
                        echo "OUTPUTS"
                        echo "==================================="
                        terraform output
                      else
                        echo "##vso[task.logissue type=error]Terraform apply failed"
                        exit 1
                      fi
                
                - task: AzureCLI@2
                  displayName: 'Save Terraform Outputs'
                  inputs:
                    azureSubscription: $(serviceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    workingDirectory: '$(workingDirectory)'
                    inlineScript: |
                      # Export outputs to JSON
                      terraform output -json > outputs.json
                      
                      echo "Terraform outputs saved to outputs.json"
                
                - task: PublishPipelineArtifact@1
                  displayName: 'Publish Terraform Outputs'
                  inputs:
                    targetPath: '$(workingDirectory)/outputs.json'
                    artifact: 'terraform-outputs-${{ parameters.environment }}'
                    publishLocation: 'pipeline'

  - stage: PostDeployment
    displayName: 'Post-Deployment Validation'
    dependsOn: DeployInfrastructure
    condition: succeeded()
    jobs:
      - job: ValidateDeployment
        displayName: 'Validate Deployed Resources'
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Terraform Outputs'
            inputs:
              artifact: 'terraform-outputs-${{ parameters.environment }}'
              path: '$(System.DefaultWorkingDirectory)/outputs'
          
          - task: AzureCLI@2
            displayName: 'Verify Resources Exist'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                echo "==================================="
                echo "POST-DEPLOYMENT VERIFICATION"
                echo "==================================="
                echo "Environment: ${{ parameters.environment }}"
                echo ""

                OUTPUTS_FILE="$(System.DefaultWorkingDirectory)/outputs/outputs.json"
                PASS=0
                FAIL=0

                if [ ! -f "$OUTPUTS_FILE" ]; then
                  echo "##vso[task.logissue type=error]No outputs file found"
                  exit 1
                fi

                echo "Terraform outputs:"
                cat $OUTPUTS_FILE | jq '.'
                echo ""

                # â”€â”€ Verify Resource Group â”€â”€
                RG_NAME=$(cat $OUTPUTS_FILE | jq -r '.resource_group_name.value // empty')
                if [ -n "$RG_NAME" ]; then
                  if az group show --name "$RG_NAME" > /dev/null 2>&1; then
                    echo "âœ“ Resource Group '$RG_NAME' exists"
                    PASS=$((PASS+1))
                  else
                    echo "##vso[task.logissue type=error]Resource Group '$RG_NAME' NOT FOUND"
                    FAIL=$((FAIL+1))
                  fi
                fi

                # â”€â”€ Verify VNet (if present) â”€â”€
                VNET_NAME=$(cat $OUTPUTS_FILE | jq -r '.vnet_name.value // empty')
                if [ -n "$VNET_NAME" ] && [ -n "$RG_NAME" ]; then
                  if az network vnet show --name "$VNET_NAME" --resource-group "$RG_NAME" > /dev/null 2>&1; then
                    echo "âœ“ VNet '$VNET_NAME' exists"
                    PASS=$((PASS+1))
                  else
                    echo "##vso[task.logissue type=warning]VNet '$VNET_NAME' not found"
                    FAIL=$((FAIL+1))
                  fi
                fi

                # â”€â”€ Verify Key Vault (if present) â”€â”€
                KV_NAME=$(cat $OUTPUTS_FILE | jq -r '.key_vault_name.value // empty')
                if [ -n "$KV_NAME" ]; then
                  if az keyvault show --name "$KV_NAME" > /dev/null 2>&1; then
                    echo "âœ“ Key Vault '$KV_NAME' exists"
                    PASS=$((PASS+1))
                  else
                    echo "##vso[task.logissue type=warning]Key Vault '$KV_NAME' not found"
                    FAIL=$((FAIL+1))
                  fi
                fi

                # â”€â”€ Verify Log Analytics Workspace (if present) â”€â”€
                LAW_ID=$(cat $OUTPUTS_FILE | jq -r '.log_analytics_workspace_id.value // empty')
                if [ -n "$LAW_ID" ]; then
                  if az monitor log-analytics workspace show --ids "$LAW_ID" > /dev/null 2>&1; then
                    echo "âœ“ Log Analytics Workspace exists"
                    PASS=$((PASS+1))
                  else
                    echo "##vso[task.logissue type=warning]Log Analytics Workspace not found"
                    FAIL=$((FAIL+1))
                  fi
                fi

                # â”€â”€ Verify AKS Cluster (if present) â”€â”€
                AKS_NAME=$(cat $OUTPUTS_FILE | jq -r '.aks_cluster_name.value // empty')
                if [ -n "$AKS_NAME" ] && [ -n "$RG_NAME" ]; then
                  if az aks show --name "$AKS_NAME" --resource-group "$RG_NAME" > /dev/null 2>&1; then
                    echo "âœ“ AKS Cluster '$AKS_NAME' exists and is reachable"
                    PASS=$((PASS+1))
                  else
                    echo "##vso[task.logissue type=warning]AKS Cluster '$AKS_NAME' not found"
                    FAIL=$((FAIL+1))
                  fi
                fi

                echo ""
                echo "==================================="
                echo "VERIFICATION SUMMARY"
                echo "==================================="
                echo "  Passed: $PASS"
                echo "  Failed: $FAIL"
                echo ""

                if [ "$FAIL" -gt 0 ]; then
                  echo "##vso[task.logissue type=warning]$FAIL resource(s) failed post-deployment verification"
                fi
                echo "âœ“ Post-deployment validation completed"
      
      - job: NotifyTeam
        displayName: 'Send Deployment Notification'
        dependsOn: ValidateDeployment
        condition: succeeded()
        steps:
          - task: PowerShell@2
            displayName: 'Prepare Notification'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "==================================="
                Write-Host "âœ“ DEPLOYMENT SUCCESSFUL"
                Write-Host "==================================="
                Write-Host "Environment: ${{ parameters.environment }}"
                Write-Host "Build: $(Build.BuildNumber)"
                Write-Host "Deployed By: $(Build.RequestedFor)"
                Write-Host "Repository: $(Build.Repository.Name)"
                Write-Host "Commit: $(Build.SourceVersion)"
                Write-Host ""
                Write-Host "View Details: $(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
                Write-Host ""
                
                # Here you could add integration with Teams, Slack, Email, etc.
                # Example: Send to Teams webhook
                # Invoke-WebRequest -Uri $env:TEAMS_WEBHOOK -Method Post -Body $jsonBody
