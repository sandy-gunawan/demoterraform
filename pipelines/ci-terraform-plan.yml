# CI Pipeline - Terraform Plan
# Runs on Pull Request to validate and plan infrastructure changes
# No changes are applied - only validation and planning
# Includes: format check, validation, security scanning, cost estimation, and plan

trigger: none  # Only run on PR

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - 'infra/**'
      - 'pipelines/**'

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - staging
      - prod
  - name: deploymentTarget
    displayName: 'Terraform Root Module Path'
    type: string
    default: 'infra/envs'
    values:
      - infra/envs
      - infra/platform
      - infra/envs-multiapp
  - name: varFiles
    displayName: 'Var files (comma-separated, optional)'
    type: string
    default: ''

variables:
  - name: terraformVersion
    value: '1.5.7'
  - name: workingDirectory
    value: '$(System.DefaultWorkingDirectory)/${{ parameters.deploymentTarget }}/${{ parameters.environment }}'
  - name: serviceConnection
    value: 'sc-azure-oidc-or-mi'  # Azure service connection name
  - name: azureSubscription
    value: ''  # Set in pipeline variables

pool:
  vmImage: 'ubuntu-latest'

stages:
  # â”€â”€â”€ Stage 1: Secret scanning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: SecretScan
    displayName: 'Secret Scanning (GitLeaks)'
    jobs:
      - job: GitLeaks
        displayName: 'Scan for Leaked Secrets'
        steps:
          - checkout: self
            fetchDepth: 0  # Full history for comprehensive scanning

          - task: Bash@3
            displayName: 'Install & Run GitLeaks'
            inputs:
              targetType: 'inline'
              script: |
                echo "Installing GitLeaks..."
                GITLEAKS_VERSION="8.18.1"
                wget -q "https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz" -O gitleaks.tar.gz
                tar -xzf gitleaks.tar.gz gitleaks
                chmod +x gitleaks

                echo "Running GitLeaks scan..."
                ./gitleaks detect \
                  --source . \
                  --report-format json \
                  --report-path gitleaks-report.json \
                  --verbose || SCAN_EXIT=$?

                if [ "${SCAN_EXIT:-0}" -ne 0 ]; then
                  echo "##vso[task.logissue type=error]GitLeaks detected secrets in the repository!"
                  echo "Review the report artifact for details."
                  exit 1
                fi

                echo "âœ“ No secrets detected"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish GitLeaks Report'
            condition: always()
            inputs:
              targetPath: 'gitleaks-report.json'
              artifact: 'gitleaks-report'
              publishLocation: 'pipeline'

  # â”€â”€â”€ Stage 2: Terraform format + validate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: Validate
    displayName: 'Terraform Validation'
    dependsOn: SecretScan
    jobs:
      - job: TerraformFormat
        displayName: 'Check Terraform Format'
        steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: Bash@3
            displayName: 'Check Terraform Format'
            inputs:
              targetType: 'inline'
              script: |
                terraform fmt -check -recursive infra/
                if [ $? -ne 0 ]; then
                  echo "##vso[task.logissue type=error]Terraform files are not formatted correctly. Run 'terraform fmt -recursive' locally."
                  exit 1
                fi
                echo "âœ“ All Terraform files are properly formatted"

      - job: TerraformValidate
        displayName: 'Validate Terraform Configuration'
        dependsOn: TerraformFormat
        steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd $(workingDirectory)
                
                # Initialize Terraform
                terraform init \
                  -backend=false \
                  -input=false
                
                echo "âœ“ Terraform initialized successfully"
          
          - task: AzureCLI@2
            displayName: 'Terraform Validate'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd $(workingDirectory)
                
                # Validate configuration
                terraform validate
                
                echo "âœ“ Terraform configuration is valid"

  - stage: Plan
    displayName: 'Terraform Plan'
    dependsOn: Validate
    jobs:
      - job: TerraformPlan
        displayName: 'Generate Terraform Plan'
        steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Terraform Init with Backend'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                cd $(workingDirectory)
                
                # Set OIDC environment variables for Terraform
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                export ARM_USE_OIDC=true
                
                # Initialize with backend
                terraform init \
                  -input=false \
                  -upgrade=false
                
                echo "âœ“ Terraform backend initialized"
          
          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                cd $(workingDirectory)
                
                # Set OIDC environment variables
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                export ARM_USE_OIDC=true

                # Build var-file arguments
                if [ -z "${{ parameters.varFiles }}" ]; then
                  TF_VAR_ARGS="-var-file=${{ parameters.environment }}.tfvars"
                else
                  TF_VAR_ARGS=""
                  IFS=',' read -ra FILES <<< "${{ parameters.varFiles }}"
                  for f in "${FILES[@]}"; do
                    file_trimmed=$(echo "$f" | xargs)
                    TF_VAR_ARGS="$TF_VAR_ARGS -var-file=$file_trimmed"
                  done
                fi
                
                # Generate plan
                echo "Using var args: $TF_VAR_ARGS"
                terraform plan $TF_VAR_ARGS -out=tfplan -input=false -detailed-exitcode || EXIT_CODE=$?
                EXIT_CODE=${EXIT_CODE:-0}
                
                # Handle exit codes
                # 0 = No changes, 1 = Error, 2 = Changes present
                if [ "$EXIT_CODE" -eq 0 ]; then
                  echo "âœ“ No infrastructure changes detected"
                elif [ "$EXIT_CODE" -eq 2 ]; then
                  echo "âš  Infrastructure changes detected - review plan carefully"
                elif [ "$EXIT_CODE" -eq 1 ]; then
                  echo "##vso[task.logissue type=error]Terraform plan failed"
                  exit 1
                fi
                
                # Show plan in human-readable format
                echo ""
                echo "==================================="
                echo "Terraform Plan Summary"
                echo "==================================="
                terraform show tfplan
          
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Terraform Plan'
            condition: succeeded()
            inputs:
              targetPath: '$(workingDirectory)/tfplan'
              artifact: 'terraform-plan-${{ parameters.environment }}'
              publishLocation: 'pipeline'
          
          - task: PowerShell@2
            displayName: 'Generate Plan Comment for PR'
            condition: succeeded()
            inputs:
              targetType: 'inline'
              script: |
                cd $(workingDirectory)
                
                # Generate markdown summary
                $planSummary = terraform show -no-color tfplan
                
                # Create PR comment content
                $comment = @"
                ## ðŸ“‹ Terraform Plan Summary
                
                **Environment**: ${{ parameters.environment }}
                **Deployment Target**: ${{ parameters.deploymentTarget }}/${{ parameters.environment }}
                **Var Files**: ${{ parameters.varFiles }}
                **Triggered By**: $(Build.RequestedFor)
                **Build**: [$(Build.BuildNumber)]($(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId))
                
                ### Plan Output
                ``````
                $planSummary
                ``````
                
                ### Next Steps
                - Review the plan carefully
                - Ensure all changes are expected
                - Merge PR if approved
                - Apply pipeline will require manual approval before deployment
                "@
                
                Write-Host "Plan summary prepared for PR comment"
                Write-Output $comment | Out-File -FilePath "$(Build.ArtifactStagingDirectory)/plan-summary.md"
          
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Plan Summary'
            condition: succeeded()
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/plan-summary.md'
              artifact: 'plan-summary'
              publishLocation: 'pipeline'

  - stage: SecurityScan
    displayName: 'IaC Security Scanning (Checkov)'
    dependsOn: Plan
    condition: succeeded()
    jobs:
      - job: Checkov
        displayName: 'Run Checkov Security Scan'
        steps:
          - checkout: self
          
          - task: UsePythonVersion@0
            displayName: 'Use Python 3.x'
            inputs:
              versionSpec: '3.x'

          - task: Bash@3
            displayName: 'Install & Run Checkov'
            inputs:
              targetType: 'inline'
              script: |
                pip install --quiet checkov

                echo "Running Checkov against infra/ ..."
                checkov \
                  --directory infra/ \
                  --config-file .checkov.yml \
                  --output cli \
                  --output junitxml \
                  --output-file-path console,$(Build.ArtifactStagingDirectory)/checkov-results.xml \
                  --soft-fail || true

                echo ""
                echo "âœ“ Checkov scan complete â€” review results above"
            continueOnError: true

          - task: PublishTestResults@2
            displayName: 'Publish Checkov Results'
            condition: always()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Build.ArtifactStagingDirectory)/checkov-results.xml'
              testRunTitle: 'Checkov IaC Security Scan'

  # â”€â”€â”€ Stage 5: Infracost cost estimation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: CostEstimation
    displayName: 'Cost Estimation (Infracost)'
    dependsOn: Plan
    condition: succeeded()
    jobs:
      - job: Infracost
        displayName: 'Estimate Infrastructure Cost'
        steps:
          - checkout: self

          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)

          - task: AzureCLI@2
            displayName: 'Terraform Init (for Infracost)'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              addSpnToEnvironment: true
              inlineScript: |
                cd $(workingDirectory)
                export ARM_CLIENT_ID=$servicePrincipalId
                export ARM_TENANT_ID=$tenantId
                export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                export ARM_USE_OIDC=true
                terraform init -backend=false -input=false

          - task: Bash@3
            displayName: 'Install & Run Infracost'
            env:
              INFRACOST_API_KEY: $(INFRACOST_API_KEY)  # Set in pipeline variables or Key Vault
            inputs:
              targetType: 'inline'
              script: |
                if [ -z "$INFRACOST_API_KEY" ]; then
                  echo "##vso[task.logissue type=warning]INFRACOST_API_KEY not set â€” skipping cost estimation"
                  echo "Get a free key at https://www.infracost.io/docs/"
                  exit 0
                fi

                # Install Infracost
                curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh

                # Generate cost breakdown
                infracost breakdown \
                  --path $(workingDirectory) \
                  --format json \
                  --out-file $(Build.ArtifactStagingDirectory)/infracost.json

                # Generate human-readable output
                infracost output \
                  --path $(Build.ArtifactStagingDirectory)/infracost.json \
                  --format table

                echo ""
                echo "âœ“ Cost estimation complete"

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Cost Report'
            condition: succeededOrFailed()
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/infracost.json'
              artifact: 'infracost-report-${{ parameters.environment }}'
              publishLocation: 'pipeline'
